{"ast":null,"code":"'use strict';\n\nvar _interopRequireDefault = require(\"@babel/runtime/helpers/interopRequireDefault\");\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.default = void 0;\n\nvar _classCallCheck2 = _interopRequireDefault(require(\"@babel/runtime/helpers/classCallCheck\"));\n\nvar _createClass2 = _interopRequireDefault(require(\"@babel/runtime/helpers/createClass\"));\n\nvar _ViscousFluidInterpolator = _interopRequireDefault(require(\"./ViscousFluidInterpolator\"));\n\nvar _AnimationUtils = require(\"./AnimationUtils\");\n\nvar SCROLL_FRICTION = 0.03;\nvar DEFAULT_DURATION = 250;\nvar SCROLL_MODE = 0;\nvar FLING_MODE = 1;\nvar DECELERATION_RATE = Math.log(0.78) / Math.log(0.9);\nvar INFLEXION = 0.35;\nvar START_TENSION = 0.5;\nvar END_TENSION = 1.0;\nvar P1 = START_TENSION * INFLEXION;\nvar P2 = 1.0 - END_TENSION * (1.0 - INFLEXION);\nvar NB_SAMPLES = 100;\nvar SPLINE_POSITION = [];\nvar SPLINE_TIME = [];\nvar GRAVITY_EARTH = 9.80665;\n\n(function () {\n  var x_min = 0;\n  var y_min = 0;\n\n  for (var i = 0; i < NB_SAMPLES; i++) {\n    var alpha = i / NB_SAMPLES;\n    var x_max = 1;\n    var x = void 0,\n        tx = void 0,\n        coef = void 0;\n\n    while (true) {\n      x = x_min + (x_max - x_min) / 2.0;\n      coef = 3.0 * x * (1.0 - x);\n      tx = coef * ((1.0 - x) * P1 + x * P2) + x * x * x;\n      if (Math.abs(tx - alpha) < 1E-5) break;\n      if (tx > alpha) x_max = x;else x_min = x;\n    }\n\n    SPLINE_POSITION[i] = coef * ((1.0 - x) * START_TENSION + x) + x * x * x;\n    var y_max = 1.0;\n    var y = void 0,\n        dy = void 0;\n\n    while (true) {\n      y = y_min + (y_max - y_min) / 2.0;\n      coef = 3.0 * y * (1.0 - y);\n      dy = coef * ((1.0 - y) * START_TENSION + y) + y * y * y;\n      if (Math.abs(dy - alpha) < 1E-5) break;\n      if (dy > alpha) y_max = y;else y_min = y;\n    }\n\n    SPLINE_TIME[i] = coef * ((1.0 - y) * P1 + y * P2) + y * y * y;\n  }\n\n  SPLINE_POSITION[NB_SAMPLES] = SPLINE_TIME[NB_SAMPLES] = 1.0;\n})();\n\nfunction signum(number) {\n  if (isNaN(number)) {\n    return NaN;\n  }\n\n  var sig = number;\n\n  if (number > 0) {\n    sig = 1;\n  } else if (number < 0) {\n    sig = -1;\n  }\n\n  return sig;\n}\n\nvar Scroller = function () {\n  function Scroller(flywheel, onScrollCallback) {\n    (0, _classCallCheck2.default)(this, Scroller);\n    this.mCurrX = 0;\n    this.mCurrY = 0;\n    this.mFinished = true;\n    this.mInterpolator = _ViscousFluidInterpolator.default;\n    this.mPpi = 160;\n    this.mDeceleration = this.computeDeceleration(SCROLL_FRICTION);\n    this.mFlywheel = flywheel;\n    this.mPhysicalCoeff = this.computeDeceleration(0.84);\n    this.mFlingFriction = SCROLL_FRICTION;\n    this.onScrollCallback = onScrollCallback;\n  }\n\n  (0, _createClass2.default)(Scroller, [{\n    key: \"computeDeceleration\",\n    value: function computeDeceleration(friction) {\n      return GRAVITY_EARTH * 39.37 * this.mPpi * friction;\n    }\n  }, {\n    key: \"isFinished\",\n    value: function isFinished() {\n      return this.mFinished;\n    }\n  }, {\n    key: \"forceFinished\",\n    value: function forceFinished(finished) {\n      this.mFinished = finished;\n    }\n  }, {\n    key: \"getCurrX\",\n    value: function getCurrX() {\n      return this.mCurrX;\n    }\n  }, {\n    key: \"getCurrY\",\n    value: function getCurrY() {\n      return this.mCurrY;\n    }\n  }, {\n    key: \"getCurrVelocity\",\n    value: function getCurrVelocity() {\n      return this.mMode === FLING_MODE ? this.mCurrVelocity : this.mVelocity - this.mDeceleration * this.timePassed() / 2000.0;\n    }\n  }, {\n    key: \"computeScrollOffset\",\n    value: function computeScrollOffset() {\n      if (this.mFinished) {\n        this.onScrollCallback && this.onScrollCallback(0, 0, this);\n        return false;\n      }\n\n      var timePassed = (0, _AnimationUtils.currentAnimationTimeMillis)() - this.mStartTime;\n\n      if (timePassed < this.mDuration) {\n        switch (this.mMode) {\n          case SCROLL_MODE:\n            var x = this.mInterpolator.getInterpolation(timePassed * this.mDurationReciprocal);\n            this.mCurrX = this.mStartX + Math.round(x * this.mDeltaX);\n            this.mCurrY = this.mStartY + Math.round(x * this.mDeltaY);\n            break;\n\n          case FLING_MODE:\n            var t = timePassed / this.mDuration;\n            var index = parseInt(NB_SAMPLES * t);\n            var distanceCoef = 1;\n            var velocityCoef = 0;\n\n            if (index < NB_SAMPLES) {\n              var t_inf = index / NB_SAMPLES;\n              var t_sup = (index + 1) / NB_SAMPLES;\n              var d_inf = SPLINE_POSITION[index];\n              var d_sup = SPLINE_POSITION[index + 1];\n              velocityCoef = (d_sup - d_inf) / (t_sup - t_inf);\n              distanceCoef = d_inf + (t - t_inf) * velocityCoef;\n            }\n\n            this.mCurrVelocity = velocityCoef * this.mDistance / this.mDuration * 1000;\n            this.mCurrX = this.mStartX + Math.round(distanceCoef * (this.mFinalX - this.mStartX));\n            this.mCurrY = this.mStartY + Math.round(distanceCoef * (this.mFinalY - this.mStartY));\n            this.mCurrY = Math.min(this.mCurrY, this.mMaxY);\n            this.mCurrY = Math.max(this.mCurrY, this.mMinY);\n\n            if (this.mCurrX == this.mFinalX && this.mCurrY == this.mFinalY) {\n              this.mFinished = true;\n            }\n\n            break;\n        }\n      } else {\n        this.mCurrX = this.mFinalX;\n        this.mCurrY = this.mFinalY;\n        this.mFinished = true;\n      }\n\n      var dx = this.mCurrX - this.mLastX;\n      var dy = this.mCurrY - this.mLastY;\n      this.mLastX = this.mCurrX;\n      this.mLastY = this.mCurrY;\n      this.onScrollCallback && this.onScrollCallback(dx, dy, this);\n\n      if (dx === 0 && dy === 0 && this.mFinished) {\n        return false;\n      }\n\n      return true;\n    }\n  }, {\n    key: \"startScroll\",\n    value: function (_startScroll) {\n      function startScroll(_x, _x2, _x3, _x4) {\n        return _startScroll.apply(this, arguments);\n      }\n\n      startScroll.toString = function () {\n        return _startScroll.toString();\n      };\n\n      return startScroll;\n    }(function (startX, startY, dx, dy) {\n      startScroll(startX, startY, dx, dy, DEFAULT_DURATION);\n    })\n  }, {\n    key: \"startScroll\",\n    value: function startScroll(startX, startY, dx, dy, duration) {\n      this.mMode = SCROLL_MODE;\n      this.mFinished = false;\n      this.mDuration = duration;\n      this.mStartTime = (0, _AnimationUtils.currentAnimationTimeMillis)();\n      this.mStartX = startX;\n      this.mStartY = startY;\n      this.mFinalX = startX + dx;\n      this.mFinalY = startY + dy;\n      this.mDeltaX = dx;\n      this.mDeltaY = dy;\n      this.mDurationReciprocal = 1.0 / this.mDuration;\n      this.mLastX = this.mStartX;\n      this.mLastY = this.mStartY;\n      this.performAnimation();\n    }\n  }, {\n    key: \"fling\",\n    value: function fling(startX, startY, velocityX, velocityY, minX, maxX, minY, maxY) {\n      if (this.mFlywheel && !this.mFinished) {\n        var oldVel = this.getCurrVelocity();\n        var dx = this.mFinalX - this.mStartX;\n        var dy = this.mFinalY - this.mStartY;\n        var hyp = Math.hypot(dx, dy);\n        var ndx = dx / hyp;\n        var ndy = dy / hyp;\n        var oldVelocityX = ndx * oldVel;\n        var oldVelocityY = ndy * oldVel;\n\n        if (signum(velocityX) === signum(oldVelocityX) && signum(velocityY) === signum(oldVelocityY)) {\n          velocityX += oldVelocityX;\n          velocityY += oldVelocityY;\n        }\n      }\n\n      this.mMode = FLING_MODE;\n      this.mFinished = false;\n      var velocity = Math.hypot(velocityX, velocityY);\n      this.mVelocity = velocity;\n      this.mDuration = this.getSplineFlingDuration(velocity);\n      this.mStartTime = (0, _AnimationUtils.currentAnimationTimeMillis)();\n      this.mStartX = startX;\n      this.mStartY = startY;\n      var coeffX = velocity == 0 ? 1.0 : velocityX / velocity;\n      var coeffY = velocity == 0 ? 1.0 : velocityY / velocity;\n      var totalDistance = this.getSplineFlingDistance(velocity);\n      this.mDistance = totalDistance * signum(velocity);\n      this.mMinX = minX;\n      this.mMaxX = maxX;\n      this.mMinY = minY;\n      this.mMaxY = maxY;\n      this.mFinalX = startX + Math.round(totalDistance * coeffX);\n      this.mFinalX = Math.min(this.mFinalX, this.mMaxX);\n      this.mFinalX = Math.max(this.mFinalX, this.mMinX);\n      this.mFinalY = startY + Math.round(totalDistance * coeffY);\n      this.mFinalY = Math.min(this.mFinalY, this.mMaxY);\n      this.mFinalY = Math.max(this.mFinalY, this.mMinY);\n      this.mLastX = this.mStartX;\n      this.mLastY = this.mStartY;\n      this.performAnimation();\n    }\n  }, {\n    key: \"getSplineDeceleration\",\n    value: function getSplineDeceleration(velocity) {\n      return Math.log(INFLEXION * Math.abs(velocity) / (this.mFlingFriction * this.mPhysicalCoeff));\n    }\n  }, {\n    key: \"getSplineFlingDuration\",\n    value: function getSplineFlingDuration(velocity) {\n      var l = this.getSplineDeceleration(velocity);\n      var decelMinusOne = DECELERATION_RATE - 1.0;\n      return 1000.0 * Math.exp(l / decelMinusOne);\n    }\n  }, {\n    key: \"getSplineFlingDistance\",\n    value: function getSplineFlingDistance(velocity) {\n      var l = this.getSplineDeceleration(velocity);\n      var decelMinusOne = DECELERATION_RATE - 1.0;\n      return this.mFlingFriction * this.mPhysicalCoeff * Math.exp(DECELERATION_RATE / decelMinusOne * l);\n    }\n  }, {\n    key: \"performAnimation\",\n    value: function performAnimation() {\n      if (this.computeScrollOffset()) {\n        requestAnimationFrame(this.performAnimation.bind(this));\n      } else {}\n    }\n  }, {\n    key: \"abortAnimation\",\n    value: function abortAnimation() {\n      this.mCurrX = this.mFinalX;\n      this.mCurrY = this.mFinalY;\n      this.mFinished = true;\n    }\n  }, {\n    key: \"extendDuration\",\n    value: function extendDuration(extend) {\n      var passed = timePassed();\n      this.mDuration = passed + extend;\n      this.mDurationReciprocal = 1.0 / this.mDuration;\n      this.mFinished = false;\n    }\n  }, {\n    key: \"timePassed\",\n    value: function timePassed() {\n      return (0, _AnimationUtils.currentAnimationTimeMillis)() - this.mStartTime;\n    }\n  }, {\n    key: \"setFinalX\",\n    value: function setFinalX(newX) {\n      this.mFinalX = newX;\n      this.mDeltaX = this.mFinalX - this.mStartX;\n      this.mFinished = false;\n    }\n  }, {\n    key: \"setFinalY\",\n    value: function setFinalY(newY) {\n      this.mFinalY = newY;\n      this.mDeltaY = this.mFinalY - this.mStartY;\n      this.mFinished = false;\n    }\n  }, {\n    key: \"debugInfo\",\n    value: function debugInfo() {\n      return 'cur=' + this.mCurrX + ' ' + this.mCurrY + ', final=' + this.mFinalX + ' ' + this.mFinalY;\n    }\n  }]);\n  return Scroller;\n}();\n\nexports.default = Scroller;","map":{"version":3,"sources":["/Users/accedo/Desktop/albums/node_modules/react-native-scroller/library/Scroller.js"],"names":["SCROLL_FRICTION","DEFAULT_DURATION","SCROLL_MODE","FLING_MODE","DECELERATION_RATE","Math","log","INFLEXION","START_TENSION","END_TENSION","P1","P2","NB_SAMPLES","SPLINE_POSITION","SPLINE_TIME","GRAVITY_EARTH","x_min","y_min","i","alpha","x_max","x","tx","coef","abs","y_max","y","dy","signum","number","isNaN","NaN","sig","Scroller","flywheel","onScrollCallback","mCurrX","mCurrY","mFinished","mInterpolator","ViscousFluidInterpolator","mPpi","mDeceleration","computeDeceleration","mFlywheel","mPhysicalCoeff","mFlingFriction","friction","finished","mMode","mCurrVelocity","mVelocity","timePassed","mStartTime","mDuration","getInterpolation","mDurationReciprocal","mStartX","round","mDeltaX","mStartY","mDeltaY","t","index","parseInt","distanceCoef","velocityCoef","t_inf","t_sup","d_inf","d_sup","mDistance","mFinalX","mFinalY","min","mMaxY","max","mMinY","dx","mLastX","mLastY","startX","startY","startScroll","duration","performAnimation","velocityX","velocityY","minX","maxX","minY","maxY","oldVel","getCurrVelocity","hyp","hypot","ndx","ndy","oldVelocityX","oldVelocityY","velocity","getSplineFlingDuration","coeffX","coeffY","totalDistance","getSplineFlingDistance","mMinX","mMaxX","l","getSplineDeceleration","decelMinusOne","exp","computeScrollOffset","requestAnimationFrame","bind","extend","passed","newX","newY"],"mappings":"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","sourcesContent":["'use strict';\n\n/**\n * Inspired by Android Scroller\n */\n\nimport ViscousFluidInterpolator from './ViscousFluidInterpolator';\nimport {currentAnimationTimeMillis} from'./AnimationUtils';\n\n/**\n * The coefficient of friction applied to flings/scrolls.\n * @type {number}\n */\n//const SCROLL_FRICTION = 0.015;\nconst SCROLL_FRICTION = 0.03;\n\nconst DEFAULT_DURATION = 250;\nconst SCROLL_MODE = 0;\nconst FLING_MODE = 1;\n\nconst DECELERATION_RATE = Math.log(0.78) / Math.log(0.9);\nconst INFLEXION = 0.35; // Tension lines cross at (INFLEXION, 1)\nconst START_TENSION = 0.5;\nconst END_TENSION = 1.0;\nconst P1 = START_TENSION * INFLEXION;\nconst P2 = 1.0 - END_TENSION * (1.0 - INFLEXION);\n\nconst NB_SAMPLES = 100;\nconst SPLINE_POSITION = [];\nconst SPLINE_TIME = [];\n\nconst GRAVITY_EARTH = 9.80665;\n\n(function () {\n  var x_min = 0;\n  var y_min = 0;\n  for (let i = 0; i < NB_SAMPLES; i++) {\n    let alpha = i / NB_SAMPLES;\n\n    let x_max = 1;\n    let x, tx, coef;\n    while (true) {\n      x = x_min + (x_max - x_min) / 2.0;\n      coef = 3.0 * x * (1.0 - x);\n      tx = coef * ((1.0 - x) * P1 + x * P2) + x * x * x;\n      if (Math.abs(tx - alpha) < 1E-5) break;\n      if (tx > alpha) x_max = x;\n      else x_min = x;\n    }\n    SPLINE_POSITION[i] = coef * ((1.0 - x) * START_TENSION + x) + x * x * x;\n\n    let y_max = 1.0;\n    let y, dy;\n    while (true) {\n      y = y_min + (y_max - y_min) / 2.0;\n      coef = 3.0 * y * (1.0 - y);\n      dy = coef * ((1.0 - y) * START_TENSION + y) + y * y * y;\n      if (Math.abs(dy - alpha) < 1E-5) break;\n      if (dy > alpha) y_max = y;\n      else y_min = y;\n    }\n    SPLINE_TIME[i] = coef * ((1.0 - y) * P1 + y * P2) + y * y * y;\n  }\n  SPLINE_POSITION[NB_SAMPLES] = SPLINE_TIME[NB_SAMPLES] = 1.0;\n})();\n\nfunction signum(number) {\n  if (isNaN(number)) {\n    return NaN;\n  }\n  var sig = number;\n  if (number > 0) {\n    sig = 1;\n  }\n  else if (number < 0) {\n    sig = -1;\n  }\n  return sig;\n}\n\nexport default class Scroller {\n  /**\n   *\n   * @param flywheel specify whether or not to support progressive \"flywheel\" behavior in flinging.\n   */\n  constructor(flywheel, onScrollCallback) {\n    this.mCurrX = 0;\n    this.mCurrY = 0;\n    this.mFinished = true;\n    this.mInterpolator = ViscousFluidInterpolator;\n    //this.mPpi = PixelRatio.get() * 160;\n    this.mPpi = 160;\n    this.mDeceleration = this.computeDeceleration(SCROLL_FRICTION);\n    this.mFlywheel = flywheel;\n\n    this.mPhysicalCoeff = this.computeDeceleration(0.84); // look and feel tuning\n\n    this.mFlingFriction = SCROLL_FRICTION;\n    this.onScrollCallback = onScrollCallback;\n  }\n\n  computeDeceleration(friction) {\n    return GRAVITY_EARTH * 39.37 * this.mPpi * friction;\n  }\n\n  /**\n   * Returns whether the scroller has finished scrolling.\n   * @returns {Boolean} True if the scroller has finished scrolling, false otherwise.\n   */\n  isFinished() {\n    return this.mFinished;\n  }\n\n  /**\n   * Force the finished field to a particular value.\n   * @param finished The new finished value.\n   */\n  forceFinished(finished) {\n    this.mFinished = finished;\n  }\n\n  /**\n   * Returns the current X offset in the scroll.\n   * @returns {*} The new X offset as an absolute distance from the origin.\n   */\n  getCurrX() {\n    return this.mCurrX;\n  }\n\n  /**\n   * Returns the current Y offset in the scroll.\n   * @returns {*} The new Y offset as an absolute distance from the origin.\n   */\n  getCurrY() {\n    return this.mCurrY;\n  }\n\n  getCurrVelocity() {\n    return this.mMode === FLING_MODE ?\n      this.mCurrVelocity : this.mVelocity - this.mDeceleration * this.timePassed() / 2000.0;\n  }\n\n  computeScrollOffset() {\n    if (this.mFinished) {\n      this.onScrollCallback && this.onScrollCallback(0, 0, this);\n      return false;\n    }\n\n    var timePassed = currentAnimationTimeMillis() - this.mStartTime;\n\n    if (timePassed < this.mDuration) {\n      switch (this.mMode) {\n        case SCROLL_MODE:\n          let x = this.mInterpolator.getInterpolation(timePassed * this.mDurationReciprocal);\n          this.mCurrX = this.mStartX + Math.round(x * this.mDeltaX);\n          this.mCurrY = this.mStartY + Math.round(x * this.mDeltaY);\n          break;\n        case FLING_MODE:\n          let t = timePassed / this.mDuration;\n          let index = parseInt(NB_SAMPLES * t);\n          let distanceCoef = 1;\n          let velocityCoef = 0;\n          if (index < NB_SAMPLES) {\n            let t_inf = index / NB_SAMPLES;\n            let t_sup = (index + 1) / NB_SAMPLES;\n            let d_inf = SPLINE_POSITION[index];\n            let d_sup = SPLINE_POSITION[index + 1];\n            velocityCoef = (d_sup - d_inf) / (t_sup - t_inf);\n            distanceCoef = d_inf + (t - t_inf) * velocityCoef;\n          }\n\n          this.mCurrVelocity = velocityCoef * this.mDistance / this.mDuration * 1000;\n\n          this.mCurrX = this.mStartX + Math.round(distanceCoef * (this.mFinalX - this.mStartX));\n          // Pin to mMinX <= mCurrX <= mMaxX\n          //this.mCurrX = Math.min(this.mCurrX, this.mMaxX);\n          //this.mCurrX = Math.max(this.mCurrX, this.mMinX);\n\n          this.mCurrY = this.mStartY + Math.round(distanceCoef * (this.mFinalY - this.mStartY));\n          // Pin to mMinY <= mCurrY <= mMaxY\n          this.mCurrY = Math.min(this.mCurrY, this.mMaxY);\n          this.mCurrY = Math.max(this.mCurrY, this.mMinY);\n\n          if (this.mCurrX == this.mFinalX && this.mCurrY == this.mFinalY) {\n            this.mFinished = true;\n          }\n\n          break;\n      }\n    }\n    else {\n      this.mCurrX = this.mFinalX;\n      this.mCurrY = this.mFinalY;\n      this.mFinished = true;\n    }\n\n    var dx = this.mCurrX - this.mLastX;\n    var dy = this.mCurrY - this.mLastY;\n\n    this.mLastX = this.mCurrX;\n    this.mLastY = this.mCurrY;\n\n    this.onScrollCallback && this.onScrollCallback(dx, dy, this);\n\n    if(dx === 0 && dy === 0 && this.mFinished) {\n      return false;\n    }\n    return true;\n  }\n\n  startScroll(startX, startY, dx, dy) {\n    startScroll(startX, startY, dx, dy, DEFAULT_DURATION);\n  }\n\n  startScroll(startX, startY, dx, dy, duration) {\n    this.mMode = SCROLL_MODE;\n    this.mFinished = false;\n    this.mDuration = duration;\n    this.mStartTime = currentAnimationTimeMillis();\n    this.mStartX = startX;\n    this.mStartY = startY;\n    this.mFinalX = startX + dx;\n    this.mFinalY = startY + dy;\n    this.mDeltaX = dx;\n    this.mDeltaY = dy;\n    this.mDurationReciprocal = 1.0 / this.mDuration;\n\n    this.mLastX = this.mStartX;\n    this.mLastY = this.mStartY;\n\n    this.performAnimation();\n  }\n\n  /**\n   * Start scrolling based on a fling gesture. The distance travelled will\n   * depend on the initial velocity of the fling.\n   * @param startX\n   * @param startY\n   * @param velocityX Initial velocity of the fling (X) measured in dp or pt per second\n   * @param velocityY Initial velocity of the fling (Y) measured in dp or pt per second\n   * @param minX\n   * @param maxX\n   * @param minY\n   * @param maxY\n   */\n  fling(startX, startY, velocityX, velocityY,\n        minX, maxX, minY, maxY) {\n    // Continue a scroll or fling in progress\n    if (this.mFlywheel && !this.mFinished) {\n      let oldVel = this.getCurrVelocity();\n\n      let dx = this.mFinalX - this.mStartX;\n      let dy = this.mFinalY - this.mStartY;\n      let hyp = Math.hypot(dx, dy);\n\n      let ndx = dx / hyp;\n      let ndy = dy / hyp;\n\n      let oldVelocityX = ndx * oldVel;\n      let oldVelocityY = ndy * oldVel;\n      if (signum(velocityX) === signum(oldVelocityX) &&\n        signum(velocityY) === signum(oldVelocityY)) {\n        velocityX += oldVelocityX;\n        velocityY += oldVelocityY;\n      }\n    }\n\n    this.mMode = FLING_MODE;\n    this.mFinished = false;\n\n    let velocity = Math.hypot(velocityX, velocityY);\n\n    this.mVelocity = velocity;\n    this.mDuration = this.getSplineFlingDuration(velocity);\n    this.mStartTime = currentAnimationTimeMillis();\n    this.mStartX = startX;\n    this.mStartY = startY;\n\n    let coeffX = velocity == 0 ? 1.0 : velocityX / velocity;\n    let coeffY = velocity == 0 ? 1.0 : velocityY / velocity;\n\n    let totalDistance = this.getSplineFlingDistance(velocity);\n    this.mDistance = totalDistance * signum(velocity);\n\n    this.mMinX = minX;\n    this.mMaxX = maxX;\n    this.mMinY = minY;\n    this.mMaxY = maxY;\n\n    this.mFinalX = startX + Math.round(totalDistance * coeffX);\n    // Pin to mMinX <= mFinalX <= mMaxX\n    this.mFinalX = Math.min(this.mFinalX, this.mMaxX);\n    this.mFinalX = Math.max(this.mFinalX, this.mMinX);\n\n    this.mFinalY = startY + Math.round(totalDistance * coeffY);\n    // Pin to mMinY <= mFinalY <= mMaxY\n    this.mFinalY = Math.min(this.mFinalY, this.mMaxY);\n    this.mFinalY = Math.max(this.mFinalY, this.mMinY);\n\n    this.mLastX = this.mStartX;\n    this.mLastY = this.mStartY;\n\n    this.performAnimation();\n  }\n\n  getSplineDeceleration(velocity) {\n    return Math.log(INFLEXION * Math.abs(velocity) / (this.mFlingFriction * this.mPhysicalCoeff));\n  }\n\n  getSplineFlingDuration(velocity) {\n    var l = this.getSplineDeceleration(velocity);\n    var decelMinusOne = DECELERATION_RATE - 1.0;\n    return 1000.0 * Math.exp(l / decelMinusOne);\n  }\n\n  getSplineFlingDistance(velocity) {\n    var l = this.getSplineDeceleration(velocity);\n    var decelMinusOne = DECELERATION_RATE - 1.0;\n    return this.mFlingFriction * this.mPhysicalCoeff * Math.exp(DECELERATION_RATE / decelMinusOne * l);\n  }\n\n  performAnimation() {\n    if (this.computeScrollOffset()) {\n      requestAnimationFrame(this.performAnimation.bind(this));\n    } else {\n    }\n  }\n\n  abortAnimation() {\n    this.mCurrX = this.mFinalX;\n    this.mCurrY = this.mFinalY;\n    this.mFinished = true;\n  }\n\n  extendDuration(extend) {\n    var passed = timePassed();\n    this.mDuration = passed + extend;\n    this.mDurationReciprocal = 1.0 / this.mDuration;\n    this.mFinished = false;\n  }\n\n  timePassed() {\n    return currentAnimationTimeMillis() - this.mStartTime;\n  }\n\n  setFinalX(newX) {\n    this.mFinalX = newX;\n    this.mDeltaX = this.mFinalX - this.mStartX;\n    this.mFinished = false;\n  }\n\n  setFinalY(newY) {\n    this.mFinalY = newY;\n    this.mDeltaY = this.mFinalY - this.mStartY;\n    this.mFinished = false;\n  }\n\n  debugInfo() {\n    return 'cur=' + this.mCurrX + ' ' + this.mCurrY + ', final=' + this.mFinalX + ' ' + this.mFinalY;\n  }\n}"]},"metadata":{},"sourceType":"script"}