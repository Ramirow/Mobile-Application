{"ast":null,"code":"'use strict';\n\nvar _interopRequireDefault = require(\"@babel/runtime/helpers/interopRequireDefault\");\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.default = create;\n\nvar _defineProperty2 = _interopRequireDefault(require(\"@babel/runtime/helpers/defineProperty\"));\n\nvar _extends2 = _interopRequireDefault(require(\"@babel/runtime/helpers/extends\"));\n\nvar _reactNative = require(\"react-native\");\n\nvar _TouchHistoryMath = _interopRequireDefault(require(\"./TouchHistoryMath\"));\n\nvar _TouchDistanceMath = require(\"./TouchDistanceMath\");\n\nvar _reactTimerMixin = _interopRequireDefault(require(\"react-timer-mixin\"));\n\nfunction ownKeys(object, enumerableOnly) { var keys = Object.keys(object); if (Object.getOwnPropertySymbols) { var symbols = Object.getOwnPropertySymbols(object); if (enumerableOnly) symbols = symbols.filter(function (sym) { return Object.getOwnPropertyDescriptor(object, sym).enumerable; }); keys.push.apply(keys, symbols); } return keys; }\n\nfunction _objectSpread(target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i] != null ? arguments[i] : {}; if (i % 2) { ownKeys(Object(source), true).forEach(function (key) { (0, _defineProperty2.default)(target, key, source[key]); }); } else if (Object.getOwnPropertyDescriptors) { Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)); } else { ownKeys(Object(source)).forEach(function (key) { Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key)); }); } } return target; }\n\nvar currentCentroidXOfTouchesChangedAfter = _TouchHistoryMath.default.currentCentroidXOfTouchesChangedAfter;\nvar currentCentroidYOfTouchesChangedAfter = _TouchHistoryMath.default.currentCentroidYOfTouchesChangedAfter;\nvar previousCentroidXOfTouchesChangedAfter = _TouchHistoryMath.default.previousCentroidXOfTouchesChangedAfter;\nvar previousCentroidYOfTouchesChangedAfter = _TouchHistoryMath.default.previousCentroidYOfTouchesChangedAfter;\nvar currentCentroidX = _TouchHistoryMath.default.currentCentroidX;\nvar currentCentroidY = _TouchHistoryMath.default.currentCentroidY;\nvar TAP_UP_TIME_THRESHOLD = 400;\nvar TAP_MOVE_THRESHOLD = 10;\nvar MOVE_THRESHOLD = 2;\nvar DEV = false;\n\nfunction initializeGestureState(gestureState) {\n  gestureState.moveX = 0;\n  gestureState.moveY = 0;\n  gestureState.x0 = 0;\n  gestureState.y0 = 0;\n  gestureState.dx = 0;\n  gestureState.dy = 0;\n  gestureState.vx = 0;\n  gestureState.vy = 0;\n  gestureState.numberActiveTouches = 0;\n  gestureState._accountsForMovesUpTo = 0;\n  gestureState.previousMoveX = 0;\n  gestureState.previousMoveY = 0;\n  gestureState.pinch = undefined;\n  gestureState.previousPinch = undefined;\n  gestureState.singleTapUp = false;\n  gestureState.doubleTapUp = false;\n  gestureState._singleTabFailed = false;\n}\n\nfunction updateGestureStateOnMove(gestureState, touchHistory, e) {\n  var movedAfter = gestureState._accountsForMovesUpTo;\n  var prevX = previousCentroidXOfTouchesChangedAfter(touchHistory, movedAfter);\n  var x = currentCentroidXOfTouchesChangedAfter(touchHistory, movedAfter);\n  var prevY = previousCentroidYOfTouchesChangedAfter(touchHistory, movedAfter);\n  var y = currentCentroidYOfTouchesChangedAfter(touchHistory, movedAfter);\n  var dx = x - prevX;\n  var dy = y - prevY;\n  gestureState.numberActiveTouches = touchHistory.numberActiveTouches;\n  gestureState.moveX = x;\n  gestureState.moveY = y;\n  var dt = convertToMillisecIfNeeded(touchHistory.mostRecentTimeStamp - movedAfter);\n  gestureState.vx = dx / dt;\n  gestureState.vy = dy / dt;\n  gestureState.dx += dx;\n  gestureState.dy += dy;\n  gestureState._accountsForMovesUpTo = touchHistory.mostRecentTimeStamp;\n  gestureState.previousMoveX = prevX;\n  gestureState.previousMoveY = prevY;\n  gestureState.pinch = (0, _TouchDistanceMath.pinchDistance)(touchHistory, movedAfter, true);\n  gestureState.previousPinch = (0, _TouchDistanceMath.pinchDistance)(touchHistory, movedAfter, false);\n}\n\nfunction clearInteractionHandle(interactionState) {\n  if (interactionState.handle) {\n    _reactNative.InteractionManager.clearInteractionHandle(interactionState.handle);\n\n    interactionState.handle = null;\n  }\n}\n\nfunction convertToMillisecIfNeeded(interval) {\n  if (interval > 1000000) {\n    return interval / 1000000;\n  }\n\n  return interval;\n}\n\nfunction cancelSingleTapConfirm(gestureState) {\n  if (typeof gestureState._singleTapConfirmId !== 'undefined') {\n    _reactTimerMixin.default.clearTimeout(gestureState._singleTapConfirmId);\n\n    gestureState._singleTapConfirmId = undefined;\n  }\n}\n\nfunction create(config) {\n  if (config.debug) {\n    DEV = true;\n  }\n\n  var interactionState = {\n    handle: null\n  };\n  var gestureState = {\n    stateID: Math.random()\n  };\n  initializeGestureState(gestureState);\n  var handlers = {\n    onStartShouldSetResponder: function onStartShouldSetResponder(e) {\n      DEV && console.log('onStartShouldSetResponder...');\n      cancelSingleTapConfirm(gestureState);\n      return config.onStartShouldSetResponder ? config.onStartShouldSetResponder(e, gestureState) : false;\n    },\n    onMoveShouldSetResponder: function onMoveShouldSetResponder(e) {\n      DEV && console.log('onMoveShouldSetResponder...');\n      return config.onMoveShouldSetResponder && effectiveMove(config, gestureState) ? config.onMoveShouldSetResponder(e, gestureState) : false;\n    },\n    onStartShouldSetResponderCapture: function onStartShouldSetResponderCapture(e) {\n      DEV && console.log('onStartShouldSetResponderCapture...');\n      cancelSingleTapConfirm(gestureState);\n\n      if (e.nativeEvent.touches.length === 1) {\n        initializeGestureState(gestureState);\n      }\n\n      gestureState.numberActiveTouches = e.touchHistory.numberActiveTouches;\n      return config.onStartShouldSetResponderCapture ? config.onStartShouldSetResponderCapture(e, gestureState) : false;\n    },\n    onMoveShouldSetResponderCapture: function onMoveShouldSetResponderCapture(e) {\n      DEV && console.log('onMoveShouldSetResponderCapture...');\n      var touchHistory = e.touchHistory;\n\n      if (gestureState._accountsForMovesUpTo === touchHistory.mostRecentTimeStamp) {\n        return false;\n      }\n\n      updateGestureStateOnMove(gestureState, touchHistory, e);\n      return config.onMoveShouldSetResponderCapture && effectiveMove(config, gestureState) ? config.onMoveShouldSetResponderCapture(e, gestureState) : false;\n    },\n    onResponderGrant: function onResponderGrant(e) {\n      DEV && console.log('onResponderGrant...');\n      cancelSingleTapConfirm(gestureState);\n\n      if (!interactionState.handle) {\n        interactionState.handle = _reactNative.InteractionManager.createInteractionHandle();\n      }\n\n      gestureState._grantTimestamp = e.touchHistory.mostRecentTimeStamp;\n      gestureState.x0 = currentCentroidX(e.touchHistory);\n      gestureState.y0 = currentCentroidY(e.touchHistory);\n      gestureState.dx = 0;\n      gestureState.dy = 0;\n\n      if (config.onResponderGrant) {\n        config.onResponderGrant(e, gestureState);\n      }\n\n      return config.onShouldBlockNativeResponder === undefined ? true : config.onShouldBlockNativeResponder();\n    },\n    onResponderReject: function onResponderReject(e) {\n      DEV && console.log('onResponderReject...');\n      clearInteractionHandle(interactionState);\n      config.onResponderReject && config.onResponderReject(e, gestureState);\n    },\n    onResponderRelease: function onResponderRelease(e) {\n      if (gestureState.singleTapUp) {\n        if (gestureState._lastSingleTapUp) {\n          if (convertToMillisecIfNeeded(e.touchHistory.mostRecentTimeStamp - gestureState._lastReleaseTimestamp) < TAP_UP_TIME_THRESHOLD) {\n            gestureState.doubleTapUp = true;\n          }\n        }\n\n        gestureState._lastSingleTapUp = true;\n\n        if (!gestureState.doubleTapUp) {\n          var snapshot = (0, _extends2.default)({}, gestureState);\n\n          var timeoutId = _reactTimerMixin.default.setTimeout(function () {\n            if (gestureState._singleTapConfirmId === timeoutId) {\n              DEV && console.log('onResponderSingleTapConfirmed...');\n              config.onResponderSingleTapConfirmed && config.onResponderSingleTapConfirmed(e, snapshot);\n            }\n          }, TAP_UP_TIME_THRESHOLD);\n\n          gestureState._singleTapConfirmId = timeoutId;\n        }\n      }\n\n      gestureState._lastReleaseTimestamp = e.touchHistory.mostRecentTimeStamp;\n      DEV && console.log('onResponderRelease...' + JSON.stringify(gestureState));\n      clearInteractionHandle(interactionState);\n      config.onResponderRelease && config.onResponderRelease(e, gestureState);\n      initializeGestureState(gestureState);\n    },\n    onResponderStart: function onResponderStart(e) {\n      DEV && console.log('onResponderStart...');\n      var touchHistory = e.touchHistory;\n      gestureState.numberActiveTouches = touchHistory.numberActiveTouches;\n\n      if (config.onResponderStart) {\n        config.onResponderStart(e, gestureState);\n      }\n    },\n    onResponderMove: function onResponderMove(e) {\n      var touchHistory = e.touchHistory;\n\n      if (gestureState._accountsForMovesUpTo === touchHistory.mostRecentTimeStamp) {\n        return;\n      }\n\n      updateGestureStateOnMove(gestureState, touchHistory, e);\n      DEV && console.log('onResponderMove...' + JSON.stringify(gestureState));\n\n      if (config.onResponderMove && effectiveMove(config, gestureState)) {\n        config.onResponderMove(e, gestureState);\n      }\n    },\n    onResponderEnd: function onResponderEnd(e) {\n      var touchHistory = e.touchHistory;\n      gestureState.numberActiveTouches = touchHistory.numberActiveTouches;\n\n      if (touchHistory.numberActiveTouches > 0 || convertToMillisecIfNeeded(touchHistory.mostRecentTimeStamp - gestureState._grantTimestamp) > TAP_UP_TIME_THRESHOLD || Math.abs(gestureState.dx) >= TAP_MOVE_THRESHOLD || Math.abs(gestureState.dy) >= TAP_MOVE_THRESHOLD) {\n        gestureState._singleTabFailed = true;\n      }\n\n      if (!gestureState._singleTabFailed) {\n        gestureState.singleTapUp = true;\n      }\n\n      DEV && console.log('onResponderEnd...' + JSON.stringify(gestureState));\n      clearInteractionHandle(interactionState);\n      config.onResponderEnd && config.onResponderEnd(e, gestureState);\n    },\n    onResponderTerminate: function onResponderTerminate(e) {\n      DEV && console.log('onResponderTerminate...');\n      clearInteractionHandle(interactionState);\n      config.onResponderTerminate && config.onResponderTerminate(e, gestureState);\n      initializeGestureState(gestureState);\n    },\n    onResponderTerminationRequest: function onResponderTerminationRequest(e) {\n      DEV && console.log('onResponderTerminationRequest...');\n      return config.onResponderTerminationRequest ? config.onResponderTerminationRequest(e.gestureState) : true;\n    }\n  };\n  return _objectSpread({}, handlers);\n}\n\nfunction effectiveMove(config, gestureState) {\n  if (gestureState.numberActiveTouches > 1) {\n    return true;\n  }\n\n  var moveThreshold = MOVE_THRESHOLD;\n\n  if (typeof config.moveThreshold === 'number') {\n    moveThreshold = config.minMoveDistance;\n  }\n\n  if (Math.abs(gestureState.dx) >= moveThreshold || Math.abs(gestureState.dy) >= moveThreshold) {\n    return true;\n  }\n\n  return false;\n}","map":{"version":3,"sources":["/Users/accedo/Desktop/albums/node_modules/react-native-gesture-responder/library/createResponder.js"],"names":["currentCentroidXOfTouchesChangedAfter","TouchHistoryMath","currentCentroidYOfTouchesChangedAfter","previousCentroidXOfTouchesChangedAfter","previousCentroidYOfTouchesChangedAfter","currentCentroidX","currentCentroidY","TAP_UP_TIME_THRESHOLD","TAP_MOVE_THRESHOLD","MOVE_THRESHOLD","DEV","initializeGestureState","gestureState","moveX","moveY","x0","y0","dx","dy","vx","vy","numberActiveTouches","_accountsForMovesUpTo","previousMoveX","previousMoveY","pinch","undefined","previousPinch","singleTapUp","doubleTapUp","_singleTabFailed","updateGestureStateOnMove","touchHistory","e","movedAfter","prevX","x","prevY","y","dt","convertToMillisecIfNeeded","mostRecentTimeStamp","clearInteractionHandle","interactionState","handle","InteractionManager","interval","cancelSingleTapConfirm","_singleTapConfirmId","TimerMixin","clearTimeout","create","config","debug","stateID","Math","random","handlers","onStartShouldSetResponder","console","log","onMoveShouldSetResponder","effectiveMove","onStartShouldSetResponderCapture","nativeEvent","touches","length","onMoveShouldSetResponderCapture","onResponderGrant","createInteractionHandle","_grantTimestamp","onShouldBlockNativeResponder","onResponderReject","onResponderRelease","_lastSingleTapUp","_lastReleaseTimestamp","snapshot","timeoutId","setTimeout","onResponderSingleTapConfirmed","JSON","stringify","onResponderStart","onResponderMove","onResponderEnd","abs","onResponderTerminate","onResponderTerminationRequest","moveThreshold","minMoveDistance"],"mappings":"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","sourcesContent":["/**\n * Inspired by 'PanResponder' from Facebook.\n */\n\n'use strict';\n\nimport {InteractionManager} from 'react-native';\nimport TouchHistoryMath from './TouchHistoryMath'; //copied from react/lib/TouchHistoryMath.js\nimport {pinchDistance} from './TouchDistanceMath';\nimport TimerMixin from 'react-timer-mixin';\n\nconst currentCentroidXOfTouchesChangedAfter = TouchHistoryMath.currentCentroidXOfTouchesChangedAfter;\nconst currentCentroidYOfTouchesChangedAfter = TouchHistoryMath.currentCentroidYOfTouchesChangedAfter;\nconst previousCentroidXOfTouchesChangedAfter = TouchHistoryMath.previousCentroidXOfTouchesChangedAfter;\nconst previousCentroidYOfTouchesChangedAfter = TouchHistoryMath.previousCentroidYOfTouchesChangedAfter;\nconst currentCentroidX = TouchHistoryMath.currentCentroidX;\nconst currentCentroidY = TouchHistoryMath.currentCentroidY;\n\nconst TAP_UP_TIME_THRESHOLD = 400;\nconst TAP_MOVE_THRESHOLD = 10;\nconst MOVE_THRESHOLD = 2;\n\nlet DEV = false;\n\nfunction initializeGestureState(gestureState) {\n  gestureState.moveX = 0;\n  gestureState.moveY = 0;\n  gestureState.x0 = 0;\n  gestureState.y0 = 0;\n  gestureState.dx = 0;\n  gestureState.dy = 0;\n  gestureState.vx = 0;\n  gestureState.vy = 0;\n  gestureState.numberActiveTouches = 0;\n  // All `gestureState` accounts for timeStamps up until:\n  gestureState._accountsForMovesUpTo = 0;\n\n\n  gestureState.previousMoveX = 0;\n  gestureState.previousMoveY = 0;\n  gestureState.pinch = undefined;\n  gestureState.previousPinch = undefined;\n  gestureState.singleTapUp = false;\n  gestureState.doubleTapUp = false;\n  gestureState._singleTabFailed = false;\n\n}\n\nfunction updateGestureStateOnMove(gestureState, touchHistory, e) {\n  const movedAfter = gestureState._accountsForMovesUpTo;\n  const prevX = previousCentroidXOfTouchesChangedAfter(touchHistory, movedAfter);\n  const x = currentCentroidXOfTouchesChangedAfter(touchHistory, movedAfter);\n  const prevY = previousCentroidYOfTouchesChangedAfter(touchHistory, movedAfter);\n  const y = currentCentroidYOfTouchesChangedAfter(touchHistory, movedAfter);\n  const dx = x - prevX;\n  const dy = y - prevY;\n\n  gestureState.numberActiveTouches = touchHistory.numberActiveTouches;\n  gestureState.moveX = x;\n  gestureState.moveY = y;\n\n  // TODO: This must be filtered intelligently.\n  //const dt = touchHistory.mostRecentTimeStamp - movedAfter;\n  const dt = convertToMillisecIfNeeded(touchHistory.mostRecentTimeStamp - movedAfter);\n  gestureState.vx = dx / dt;\n  gestureState.vy = dy / dt;\n  gestureState.dx += dx;\n  gestureState.dy += dy;\n  gestureState._accountsForMovesUpTo = touchHistory.mostRecentTimeStamp;\n\n\n  gestureState.previousMoveX = prevX;\n  gestureState.previousMoveY = prevY;\n  gestureState.pinch = pinchDistance(touchHistory, movedAfter, true);\n  gestureState.previousPinch = pinchDistance(touchHistory, movedAfter, false);\n}\n\nfunction clearInteractionHandle(interactionState) {\n  if (interactionState.handle) {\n    InteractionManager.clearInteractionHandle(interactionState.handle);\n    interactionState.handle = null;\n  }\n}\n\n/**\n * Due to commit https://github.com/facebook/react-native/commit/f2c1868b56bdfc8b0d6f448733848eafed2cd440,\n * Android is using nanoseconds while iOS is using milliseconds.\n * @param interval\n * @returns {*}\n */\nfunction convertToMillisecIfNeeded(interval) {\n  if (interval > 1000000) {\n    return interval / 1000000;\n  }\n  return interval;\n}\n\nfunction cancelSingleTapConfirm(gestureState) {\n  if(typeof gestureState._singleTapConfirmId !== 'undefined') {\n    TimerMixin.clearTimeout(gestureState._singleTapConfirmId);\n    gestureState._singleTapConfirmId = undefined;\n  }\n}\n\n/**\n * The config object contains same callbacks as the default gesture responder(https://facebook.github.io/react-native/docs/gesture-responder-system.html).\n * And every callback are called with an additional argument 'gestureState', like PanResponder.\n * @param config\n * @returns {{}}\n */\n\n/**\n * The config object contains same callbacks as the default gesture responder(https://facebook.github.io/react-native/docs/gesture-responder-system.html).\n * And every callback are called with an additional argument 'gestureState', like PanResponder.\n * @param config\n * @param debug true to enable debug logs\n * @returns {{}}\n */\nexport default function create(config) {\n  if(config.debug) {\n    DEV = true;\n  }\n\n  const interactionState = {\n    handle: null\n  };\n  const gestureState = {\n    // Useful for debugging\n    stateID: Math.random(),\n  };\n  initializeGestureState(gestureState);\n\n  const handlers = {\n    onStartShouldSetResponder: function (e) {\n      DEV && console.log('onStartShouldSetResponder...');\n      cancelSingleTapConfirm(gestureState);\n      return config.onStartShouldSetResponder ?\n        config.onStartShouldSetResponder(e, gestureState) :\n        false;\n    },\n    onMoveShouldSetResponder: function (e) {\n      DEV && console.log('onMoveShouldSetResponder...');\n\n      return config.onMoveShouldSetResponder && effectiveMove(config, gestureState) ?\n        config.onMoveShouldSetResponder(e, gestureState) :\n        false;\n    },\n    onStartShouldSetResponderCapture: function (e) {\n      DEV && console.log('onStartShouldSetResponderCapture...');\n      cancelSingleTapConfirm(gestureState);\n      // TODO: Actually, we should reinitialize the state any time\n      // touches.length increases from 0 active to > 0 active.\n      if (e.nativeEvent.touches.length === 1) {\n        initializeGestureState(gestureState);\n      }\n      gestureState.numberActiveTouches = e.touchHistory.numberActiveTouches;\n      return config.onStartShouldSetResponderCapture ?\n        config.onStartShouldSetResponderCapture(e, gestureState) :\n        false;\n    },\n\n    onMoveShouldSetResponderCapture: function (e) {\n      DEV && console.log('onMoveShouldSetResponderCapture...');\n      const touchHistory = e.touchHistory;\n      // Responder system incorrectly dispatches should* to current responder\n      // Filter out any touch moves past the first one - we would have\n      // already processed multi-touch geometry during the first event.\n      if (gestureState._accountsForMovesUpTo === touchHistory.mostRecentTimeStamp) {\n        return false;\n      }\n      updateGestureStateOnMove(gestureState, touchHistory, e);\n      return config.onMoveShouldSetResponderCapture && effectiveMove(config, gestureState) ?\n        config.onMoveShouldSetResponderCapture(e, gestureState) :\n        false;\n    },\n\n    onResponderGrant: function (e) {\n      DEV && console.log('onResponderGrant...');\n      cancelSingleTapConfirm(gestureState);\n      if (!interactionState.handle) {\n        interactionState.handle = InteractionManager.createInteractionHandle();\n      }\n      gestureState._grantTimestamp = e.touchHistory.mostRecentTimeStamp;\n      gestureState.x0 = currentCentroidX(e.touchHistory);\n      gestureState.y0 = currentCentroidY(e.touchHistory);\n      gestureState.dx = 0;\n      gestureState.dy = 0;\n      if (config.onResponderGrant) {\n        config.onResponderGrant(e, gestureState);\n      }\n      // TODO: t7467124 investigate if this can be removed\n      return config.onShouldBlockNativeResponder === undefined ?\n        true :\n        config.onShouldBlockNativeResponder();\n    },\n\n    onResponderReject: function (e) {\n      DEV && console.log('onResponderReject...');\n      clearInteractionHandle(interactionState);\n      config.onResponderReject && config.onResponderReject(e, gestureState);\n    },\n\n    onResponderRelease: function (e) {\n      if (gestureState.singleTapUp) {\n        if (gestureState._lastSingleTapUp) {\n          if (convertToMillisecIfNeeded(e.touchHistory.mostRecentTimeStamp - gestureState._lastReleaseTimestamp) < TAP_UP_TIME_THRESHOLD) {\n            gestureState.doubleTapUp = true;\n          }\n        }\n        gestureState._lastSingleTapUp = true;\n\n        //schedule to confirm single tap\n        if (!gestureState.doubleTapUp) {\n          const snapshot = Object.assign({}, gestureState);\n          const timeoutId = TimerMixin.setTimeout(() => {\n            if (gestureState._singleTapConfirmId === timeoutId) {\n              DEV && console.log('onResponderSingleTapConfirmed...');\n              config.onResponderSingleTapConfirmed && config.onResponderSingleTapConfirmed(e, snapshot);\n            }\n          }, TAP_UP_TIME_THRESHOLD);\n          gestureState._singleTapConfirmId = timeoutId;\n        }\n      }\n      gestureState._lastReleaseTimestamp = e.touchHistory.mostRecentTimeStamp;\n\n      DEV && console.log('onResponderRelease...' + JSON.stringify(gestureState));\n      clearInteractionHandle(interactionState);\n      config.onResponderRelease && config.onResponderRelease(e, gestureState);\n      initializeGestureState(gestureState);\n    },\n\n    onResponderStart: function (e) {\n      DEV && console.log('onResponderStart...');\n      const touchHistory = e.touchHistory;\n      gestureState.numberActiveTouches = touchHistory.numberActiveTouches;\n      if (config.onResponderStart) {\n        config.onResponderStart(e, gestureState);\n      }\n    },\n\n    onResponderMove: function (e) {\n      const touchHistory = e.touchHistory;\n      // Guard against the dispatch of two touch moves when there are two\n      // simultaneously changed touches.\n      if (gestureState._accountsForMovesUpTo === touchHistory.mostRecentTimeStamp) {\n        return;\n      }\n      // Filter out any touch moves past the first one - we would have\n      // already processed multi-touch geometry during the first event.\n      updateGestureStateOnMove(gestureState, touchHistory, e);\n\n      DEV && console.log('onResponderMove...' + JSON.stringify(gestureState));\n      if (config.onResponderMove && effectiveMove(config, gestureState)) {\n        config.onResponderMove(e, gestureState);\n      }\n    },\n\n    onResponderEnd: function (e) {\n      const touchHistory = e.touchHistory;\n      gestureState.numberActiveTouches = touchHistory.numberActiveTouches;\n\n      if (touchHistory.numberActiveTouches > 0\n        || convertToMillisecIfNeeded(touchHistory.mostRecentTimeStamp - gestureState._grantTimestamp) > TAP_UP_TIME_THRESHOLD\n        || Math.abs(gestureState.dx) >= TAP_MOVE_THRESHOLD\n        || Math.abs(gestureState.dy) >= TAP_MOVE_THRESHOLD\n      ) {\n        gestureState._singleTabFailed = true;\n      }\n      if (!gestureState._singleTabFailed) {\n        gestureState.singleTapUp = true;\n      }\n\n      DEV && console.log('onResponderEnd...' + JSON.stringify(gestureState));\n      clearInteractionHandle(interactionState);\n      config.onResponderEnd && config.onResponderEnd(e, gestureState);\n    },\n\n    onResponderTerminate: function (e) {\n      DEV && console.log('onResponderTerminate...');\n      clearInteractionHandle(interactionState);\n      config.onResponderTerminate && config.onResponderTerminate(e, gestureState);\n      initializeGestureState(gestureState);\n    },\n\n    onResponderTerminationRequest: function (e) {\n      DEV && console.log('onResponderTerminationRequest...');\n      return config.onResponderTerminationRequest ?\n        config.onResponderTerminationRequest(e.gestureState) :\n        true;\n    }\n  };\n  return {...handlers};\n}\n\n/**\n * On Android devices, the default gesture responder is too sensitive that a single tap(no move intended) may trigger a move event.\n * We can use a moveThreshold config to avoid those unwanted move events.\n * @param config\n * @param gestureState\n * @returns {boolean}\n */\nfunction effectiveMove(config, gestureState) {\n  if (gestureState.numberActiveTouches > 1) {\n    // on iOS simulator, a pinch gesture(move with alt pressed) will not change gestureState.dx(always 0)\n    return true;\n  }\n\n  let moveThreshold = MOVE_THRESHOLD;\n  if (typeof config.moveThreshold === 'number') {\n    moveThreshold = config.minMoveDistance;\n  }\n  if (Math.abs(gestureState.dx) >= moveThreshold || Math.abs(gestureState.dy) >= moveThreshold) {\n    return true;\n  }\n  return false;\n}"]},"metadata":{},"sourceType":"script"}